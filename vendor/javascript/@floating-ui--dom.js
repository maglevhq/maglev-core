// @floating-ui/dom@1.7.3 downloaded from https://ga.jspm.io/npm:@floating-ui/dom@1.7.3/dist/floating-ui.dom.mjs

import{rectToClientRect as t,detectOverflow as e,offset as n,autoPlacement as o,shift as i,flip as s,size as c,hide as r,arrow as l,inline as f,limitShift as u,computePosition as h}from"@floating-ui/core";import{round as a,createCoords as d,max as g,min as p,floor as x}from"@floating-ui/utils";import{getComputedStyle as y,isHTMLElement as m,isElement as w,getWindow as v,isWebKit as b,getFrameElement as R,getNodeScroll as L,getDocumentElement as T,isTopLayer as F,getNodeName as E,isOverflowElement as O,getParentNode as W,isLastTraversableNode as C,getOverflowAncestors as H,isContainingBlock as z,isTableElement as A,getContainingBlock as B}from"@floating-ui/utils/dom";export{getOverflowAncestors}from"@floating-ui/utils/dom";function P(t){const e=y(t);let n=parseFloat(e.width)||0;let o=parseFloat(e.height)||0;const i=m(t);const s=i?t.offsetWidth:n;const c=i?t.offsetHeight:o;const r=a(n)!==s||a(o)!==c;if(r){n=s;o=c}return{width:n,height:o,$:r}}function D(t){return w(t)?t:t.contextElement}function S(t){const e=D(t);if(!m(e))return d(1);const n=e.getBoundingClientRect();const{width:o,height:i,$:s}=P(e);let c=(s?a(n.width):n.width)/o;let r=(s?a(n.height):n.height)/i;c&&Number.isFinite(c)||(c=1);r&&Number.isFinite(r)||(r=1);return{x:c,y:r}}const V=d(0);function I(t){const e=v(t);return b()&&e.visualViewport?{x:e.visualViewport.offsetLeft,y:e.visualViewport.offsetTop}:V}function q(t,e,n){e===void 0&&(e=false);return!(!n||e&&n!==v(t))&&e}function M(e,n,o,i){n===void 0&&(n=false);o===void 0&&(o=false);const s=e.getBoundingClientRect();const c=D(e);let r=d(1);n&&(i?w(i)&&(r=S(i)):r=S(e));const l=q(c,o,i)?I(c):d(0);let f=(s.left+l.x)/r.x;let u=(s.top+l.y)/r.y;let h=s.width/r.x;let a=s.height/r.y;if(c){const t=v(c);const e=i&&w(i)?v(i):i;let n=t;let o=R(n);while(o&&i&&e!==n){const t=S(o);const e=o.getBoundingClientRect();const i=y(o);const s=e.left+(o.clientLeft+parseFloat(i.paddingLeft))*t.x;const c=e.top+(o.clientTop+parseFloat(i.paddingTop))*t.y;f*=t.x;u*=t.y;h*=t.x;a*=t.y;f+=s;u+=c;n=v(o);o=R(n)}}return t({width:h,height:a,x:f,y:u})}function N(t,e){const n=L(t).scrollLeft;return e?e.left+n:M(T(t)).left+n}function $(t,e,n){n===void 0&&(n=false);const o=t.getBoundingClientRect();const i=o.left+e.scrollLeft-(n?0:N(t,o));const s=o.top+e.scrollTop;return{x:i,y:s}}function _(t){let{elements:e,rect:n,offsetParent:o,strategy:i}=t;const s=i==="fixed";const c=T(o);const r=!!e&&F(e.floating);if(o===c||r&&s)return n;let l={scrollLeft:0,scrollTop:0};let f=d(1);const u=d(0);const h=m(o);if(h||!h&&!s){(E(o)!=="body"||O(c))&&(l=L(o));if(m(o)){const t=M(o);f=S(o);u.x=t.x+o.clientLeft;u.y=t.y+o.clientTop}}const a=!c||h||s?d(0):$(c,l,true);return{width:n.width*f.x,height:n.height*f.y,x:n.x*f.x-l.scrollLeft*f.x+u.x+a.x,y:n.y*f.y-l.scrollTop*f.y+u.y+a.y}}function j(t){return Array.from(t.getClientRects())}function k(t){const e=T(t);const n=L(t);const o=t.ownerDocument.body;const i=g(e.scrollWidth,e.clientWidth,o.scrollWidth,o.clientWidth);const s=g(e.scrollHeight,e.clientHeight,o.scrollHeight,o.clientHeight);let c=-n.scrollLeft+N(t);const r=-n.scrollTop;y(o).direction==="rtl"&&(c+=g(e.clientWidth,o.clientWidth)-i);return{width:i,height:s,x:c,y:r}}function G(t,e){const n=v(t);const o=T(t);const i=n.visualViewport;let s=o.clientWidth;let c=o.clientHeight;let r=0;let l=0;if(i){s=i.width;c=i.height;const t=b();if(!t||t&&e==="fixed"){r=i.offsetLeft;l=i.offsetTop}}return{width:s,height:c,x:r,y:l}}const J=new Set(["absolute","fixed"]);function K(t,e){const n=M(t,true,e==="fixed");const o=n.top+t.clientTop;const i=n.left+t.clientLeft;const s=m(t)?S(t):d(1);const c=t.clientWidth*s.x;const r=t.clientHeight*s.y;const l=i*s.x;const f=o*s.y;return{width:c,height:r,x:l,y:f}}function Q(e,n,o){let i;if(n==="viewport")i=G(e,o);else if(n==="document")i=k(T(e));else if(w(n))i=K(n,o);else{const t=I(e);i={x:n.x-t.x,y:n.y-t.y,width:n.width,height:n.height}}return t(i)}function U(t,e){const n=W(t);return!(n===e||!w(n)||C(n))&&(y(n).position==="fixed"||U(n,e))}function X(t,e){const n=e.get(t);if(n)return n;let o=H(t,[],false).filter((t=>w(t)&&E(t)!=="body"));let i=null;const s=y(t).position==="fixed";let c=s?W(t):t;while(w(c)&&!C(c)){const e=y(c);const n=z(c);n||e.position!=="fixed"||(i=null);const r=s?!n&&!i:!n&&e.position==="static"&&!!i&&J.has(i.position)||O(c)&&!n&&U(t,c);r?o=o.filter((t=>t!==c)):i=e;c=W(c)}e.set(t,o);return o}function Y(t){let{element:e,boundary:n,rootBoundary:o,strategy:i}=t;const s=n==="clippingAncestors"?F(e)?[]:X(e,this._c):[].concat(n);const c=[...s,o];const r=c[0];const l=c.reduce(((t,n)=>{const o=Q(e,n,i);t.top=g(o.top,t.top);t.right=p(o.right,t.right);t.bottom=p(o.bottom,t.bottom);t.left=g(o.left,t.left);return t}),Q(e,r,i));return{width:l.right-l.left,height:l.bottom-l.top,x:l.left,y:l.top}}function Z(t){const{width:e,height:n}=P(t);return{width:e,height:n}}function tt(t,e,n){const o=m(e);const i=T(e);const s=n==="fixed";const c=M(t,true,s,e);let r={scrollLeft:0,scrollTop:0};const l=d(0);function f(){l.x=N(i)}if(o||!o&&!s){(E(e)!=="body"||O(i))&&(r=L(e));if(o){const t=M(e,true,s,e);l.x=t.x+e.clientLeft;l.y=t.y+e.clientTop}else i&&f()}s&&!o&&i&&f();const u=!i||o||s?d(0):$(i,r);const h=c.left+r.scrollLeft-l.x-u.x;const a=c.top+r.scrollTop-l.y-u.y;return{x:h,y:a,width:c.width,height:c.height}}function et(t){return y(t).position==="static"}function nt(t,e){if(!m(t)||y(t).position==="fixed")return null;if(e)return e(t);let n=t.offsetParent;T(t)===n&&(n=n.ownerDocument.body);return n}function ot(t,e){const n=v(t);if(F(t))return n;if(!m(t)){let e=W(t);while(e&&!C(e)){if(w(e)&&!et(e))return e;e=W(e)}return n}let o=nt(t,e);while(o&&A(o)&&et(o))o=nt(o,e);return o&&C(o)&&et(o)&&!z(o)?n:o||B(t)||n}const it=async function(t){const e=this.getOffsetParent||ot;const n=this.getDimensions;const o=await n(t.floating);return{reference:tt(t.reference,await e(t.floating),t.strategy),floating:{x:0,y:0,width:o.width,height:o.height}}};function st(t){return y(t).direction==="rtl"}const ct={convertOffsetParentRelativeRectToViewportRelativeRect:_,getDocumentElement:T,getClippingRect:Y,getOffsetParent:ot,getElementRects:it,getClientRects:j,getDimensions:Z,getScale:S,isElement:w,isRTL:st};function rt(t,e){return t.x===e.x&&t.y===e.y&&t.width===e.width&&t.height===e.height}function lt(t,e){let n=null;let o;const i=T(t);function s(){var t;clearTimeout(o);(t=n)==null||t.disconnect();n=null}function c(r,l){r===void 0&&(r=false);l===void 0&&(l=1);s();const f=t.getBoundingClientRect();const{left:u,top:h,width:a,height:d}=f;r||e();if(!a||!d)return;const y=x(h);const m=x(i.clientWidth-(u+a));const w=x(i.clientHeight-(h+d));const v=x(u);const b=-y+"px "+-m+"px "+-w+"px "+-v+"px";const R={rootMargin:b,threshold:g(0,p(1,l))||1};let L=true;function T(e){const n=e[0].intersectionRatio;if(n!==l){if(!L)return c();n?c(false,n):o=setTimeout((()=>{c(false,1e-7)}),1e3)}n!==1||rt(f,t.getBoundingClientRect())||c();L=false}try{n=new IntersectionObserver(T,{...R,root:i.ownerDocument})}catch(t){n=new IntersectionObserver(T,R)}n.observe(t)}c(true);return s}
/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */function ft(t,e,n,o){o===void 0&&(o={});const{ancestorScroll:i=true,ancestorResize:s=true,elementResize:c=typeof ResizeObserver==="function",layoutShift:r=typeof IntersectionObserver==="function",animationFrame:l=false}=o;const f=D(t);const u=i||s?[...f?H(f):[],...H(e)]:[];u.forEach((t=>{i&&t.addEventListener("scroll",n,{passive:true});s&&t.addEventListener("resize",n)}));const h=f&&r?lt(f,n):null;let a=-1;let d=null;if(c){d=new ResizeObserver((t=>{let[o]=t;if(o&&o.target===f&&d){d.unobserve(e);cancelAnimationFrame(a);a=requestAnimationFrame((()=>{var t;(t=d)==null||t.observe(e)}))}n()}));f&&!l&&d.observe(f);d.observe(e)}let g;let p=l?M(t):null;l&&x();function x(){const e=M(t);p&&!rt(p,e)&&n();p=e;g=requestAnimationFrame(x)}n();return()=>{var t;u.forEach((t=>{i&&t.removeEventListener("scroll",n);s&&t.removeEventListener("resize",n)}));h==null||h();(t=d)==null||t.disconnect();d=null;l&&cancelAnimationFrame(g)}}const ut=e;const ht=n;const at=o;const dt=i;const gt=s;const pt=c;const xt=r;const yt=l;const mt=f;const wt=u;const vt=(t,e,n)=>{const o=new Map;const i={platform:ct,...n};const s={...i.platform,_c:o};return h(t,e,{...i,platform:s})};export{yt as arrow,at as autoPlacement,ft as autoUpdate,vt as computePosition,ut as detectOverflow,gt as flip,xt as hide,mt as inline,wt as limitShift,ht as offset,ct as platform,dt as shift,pt as size};

